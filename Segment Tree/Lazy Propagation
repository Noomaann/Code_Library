/**
*   author: Noman
**/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll ;
typedef vector<int> vi;
typedef vector<ll> vl;
#define pan cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);
// define values.
#define MOD 1000000007
#define PI 3.1415926535897932384626
/* Bit-Stuff */
#define get_set_bits(a) (__builtin_popcount(a))
#define get_set_bitsll(a) ( __builtin_popcountll(a))
#define get_trail_zero(a) (__builtin_ctz(a))
#define get_lead_zero(a) (__builtin_clz(a))
#define get_parity(a) (__builtin_parity(a))
/*  Abbrevations  */
#define ff first
#define ss second
#define mp make_pair
#define pb push_back
#define Endl "\n"
// loops
#define forin(arr,n) for(ll i=0;i<n;i++) cin>>arr[i];
// sort
#define all(V) (V).begin(),(V).end()
#define srt(V) sort(all(V))
#define srtGreat(V) sort(all(V),greater<ll>())

#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);



// Lazy Segment Tree structure
struct segmenttree {
    ll n;               
    vector<ll> st;      // segment tree array
    vector<ll> lazy;    // lazy array for propagation

    // Initialize segment tree
    void init(ll _n) {
        this->n = _n;
        st.assign(4 * n, 0);   // 4*n is enough to store segment tree
        lazy.assign(4 * n, 0); // initialize lazy array to 0
    }

    ll comb(ll a, ll b) {
        return a + b; // sum segment tree
    }

    // Propagate lazy value to children
    void propagate(ll start, ll end, ll node) {
        if (lazy[node] != 0) { // if there is pending update
            st[node] += (end - start + 1) * lazy[node]; // apply lazy value

            if (start != end) { // if not a leaf node, propagate to children
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }

            lazy[node] = 0; // clear the lazy value after propagation
        }
    }

    // Build segment tree from initial array
    void build(ll start, ll end, ll node, vector<ll>& v) {
        if (start == end) { // leaf node
            st[node] = v[start];
            return;
        }
        ll mid = (start + end) / 2;
        build(start, mid, 2 * node + 1, v);       // build left child
        build(mid + 1, end, 2 * node + 2, v);     // build right child
        st[node] = comb(st[2 * node + 1], st[2 * node + 2]); // combine children
    }

    // Range update [l, r] add val
    void update(ll start, ll end, ll l, ll r, ll node, ll val) {
        propagate(start, end, node); // propagate pending updates

        if (start > r || end < l) return; // overlap

        if (start >= l && end <= r) { // covered
            lazy[node] += val;        // mark lazy
            propagate(start, end, node); // apply immediately
            return;
        }

        // partial overlap
        ll mid = (start + end) / 2;
        update(start, mid, l, r, 2 * node + 1, val);
        update(mid + 1, end, l, r, 2 * node + 2, val);

        st[node] = comb(st[2 * node + 1], st[2 * node + 2]); // update current node
    }

    // Range query [l, r] sum
    ll query(ll start, ll end, ll l, ll r, ll node) {
        propagate(start, end, node); // propagate pending updates

        if (start > r || end < l) return 0; // overlap

        if (start >= l && end <= r) return st[node]; // covered

        // partial overlap
        ll mid = (start + end) / 2;
        ll q1 = query(start, mid, l, r, 2 * node + 1);
        ll q2 = query(mid + 1, end, l, r, 2 * node + 2);

        return comb(q1, q2); // combine results
    }

    // Wrapper functions for easier usage
    void build(vector<ll>& v) {
        build(0, n - 1, 0, v);
    }
    void update(ll l, ll r, ll val) {
        update(0, n - 1, l, r, 0, val);
    }
    ll query(ll l, ll r) {
        return query(0, n - 1, l, r, 0);
    }
};

void solve() {
    ll n, m;
    cin >> n >> m;

    vl v(n, 0); // initially array filled with zeros

    segmenttree st;
    st.init(n);
    st.build(v); // build segment tree

    while (m--) {
        int type;
        cin >> type;

        if (type == 1) { // range update
            ll l, r, val;
            cin >> l >> r >> val;
            // input is 0-based, range [l, r-1]
            st.update(l, r - 1, val);
        } else { // range query
            ll l, r;
            cin >> l >> r;
            // sum on range [l, r-1]
            cout << st.query(l, r - 1) << Endl;
        }
    }
}


int32_t main() {
    fastio;
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int t = 1;
    //cin >> t;

    while (t--) {
        solve();
    }
    return 0;
}
